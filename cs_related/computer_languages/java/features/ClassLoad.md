# 类加载机制

## class文件相关基础概念

+ class文件时一组以8为子节为基础的二进制流
+ 前四个字节为魔数，表示文件编译版本，高版本编译的class不能在低版本运行，因为低版本的jvm无法预知高版本出现了什么特性
+ 常量池：class版本之后的信息就是常量的内容，包括java意义的常量以及部分类的基础信息，全名等等
+ 访问标志：常量池之后，定义接口层次的访问信息
+ 类索引、父类索引，接口索引
+ 字段表集合：描述接口或类中声明的变量（属性）
+ 方法表合集：方法的定义和描述
+ 属性表集合：方法字节码等等内容，局部变量，throw出来的错误等


## 类加载机制

### 主要变化

+ 类型的加载、连接和初始化过程都在程序运行期间完成
+ 天生动态可扩展，可以在运行过程中在通过IO加载一个未知的接口实现

### 类加载的时机
一个类的生命周期，包括以下步骤
+ 加载
+ 验证
+ 准备
+ 解析
+ 初始化
+ 使用
+ 卸载

其中 加载 -> 验证 -> 准备 -> 初始化 -> 卸载 五个步骤‘开始’顺序是一定的，而其中的解析可能会被懒执行，其中的使用由程序逻辑而定

虚拟机规范未明确约束类加载的时间，只是规定了有五种情况虚拟机必须立即对于类进行初始化
 + 遇到特定字节码 new getstatic putstatic invokestatic
 + 反射调用的时候
 + 子类初始化的时候强制初始化父类
 + main方法所在入口虚拟机类
 + 1.7动态语言支持的时候

可以通过-XX:TraceClassLoading查看类初始化的信息

特例，java中声明数组对象不会造成类的初始化，而是会初始化一个Object的子类，对于目标类的封装，从而才能实现数组信息的安全访问，报错

接口的初始化过程稍有不同，在接口初始化的时候，并不要求父类接口初始化完毕

### 类加载的细节过程

#### 加载

#### 验证

#### 准备

#### 解析

#### 初始化

### 类加载器

