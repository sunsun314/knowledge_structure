# 类加载机制

## class文件相关基础概念

+ class文件时一组以8为子节为基础的二进制流
+ 前四个字节为魔数，表示文件编译版本，高版本编译的class不能在低版本运行，因为低版本的jvm无法预知高版本出现了什么特性
+ 常量池：class版本之后的信息就是常量的内容，包括java意义的常量以及部分类的基础信息，全名等等
+ 访问标志：常量池之后，定义接口层次的访问信息
+ 类索引、父类索引，接口索引
+ 字段表集合：描述接口或类中声明的变量（属性）
+ 方法表合集：方法的定义和描述
+ 属性表集合：方法字节码等等内容，局部变量，throw出来的错误等


## 类加载机制

### 主要变化

+ 类型的加载、连接和初始化过程都在程序运行期间完成
+ 天生动态可扩展，可以在运行过程中在通过IO加载一个未知的接口实现

### 类加载的时机
一个类的生命周期，包括以下步骤
+ 加载
+ 验证
+ 准备
+ 解析
+ 初始化
+ 使用
+ 卸载

其中 加载 -> 验证 -> 准备 -> 初始化 -> 卸载 五个步骤‘开始’顺序是一定的，而其中的解析可能会被懒执行，其中的使用由程序逻辑而定

虚拟机规范未明确约束类加载的时间，只是规定了有五种情况虚拟机必须立即对于类进行初始化
 + 遇到特定字节码 new getstatic putstatic invokestatic
 + 反射调用的时候
 + 子类初始化的时候强制初始化父类
 + main方法所在入口虚拟机类
 + 1.7动态语言支持的时候

可以通过-XX:TraceClassLoading查看类初始化的信息

特例，java中声明数组对象不会造成类的初始化，而是会初始化一个Object的子类，对于目标类的封装，从而才能实现数组信息的安全访问，报错

接口的初始化过程稍有不同，在接口初始化的时候，并不要求父类接口初始化完毕

### 类加载的细节过程

#### 加载
 主要是以下的几个步骤：
  +  获取二进制字节流
  +  将字节流的内容转换成方法区里面的运行时数据
  +  在内存中生存Class对象作为运行时的访问入口

可以通过loadClass()的重载来自定义加载的方式
和连接Linking阶段其实可以说是同时异步进行的，只不过其启动任务还是有顺序的

#### 验证
连接阶段的第一步，确保class文件的内容符合JVM的要求，相对比较严禁  
在性能角度上占据了类加载的大部分时间
主要分为以下的几个步骤：
+ 文件格式验证
+ 元数据验证(语义分析)
+ 字节码验证(字节码语法推导，避免崩溃)
+ 符号引用验证(对于外部信息匹配的验证)

#### 准备
正式为变量设定值，变量特指static的属性  

#### 解析
将常量池内的符号引用转化成直接引用的过程  
也就是引用从具体对于类和方法的描述，转化内内存地址指针的过程

#### 初始化
类加载过程的最后一步，真正开始执行java程序代码  
也可以看作是执行```<clinit>()```方法的过程  
这个方法是编译器通过收集static块中的内容组合而成的  
和构造器差不多，父类先执行，子类再执行  

### 类加载器

类加载这些详细步骤的实现就是类加载器  
